> Assume data type int is 32 bits long and uses a two's-complement
representation for signed values. Right shifts are performed arithmetically for
signed values and logically for unsigned values. The variables are declared and
initialized as follows:
```c
int x = foo();  /* Arbitrary value */
int y = bar();  /* Arbitrary value */

unsigned ux = x;
unsigned uy = y;
```
> For each of the following C expressions, either (1) argue that it is true
(evaluates to 1) for all values of x and y, or (2) give values of x and y for
which it is false (evaluates to 0):

> A. (x > 0) || (x-1 < 0)

False if `x == INT_MIN`

> B. (x & 7) != 7 || (x<<29 < 0)

False if x's third least significant bit is zero. `x<<29` will leave it as
the most significant bit of the expression, resulting in either zero or
a positive number.

> C. (x * x) >= 0

False if `x == INT_MAX/2 + 1`

For `x > INT_MAX/2 + 1` or `x < INT_MIN/2` it will be false if the most
significant bit results in 1 due to overflow.

> D. x < 0 || -x <= 0

True for all values of x. The only type of overflow in two's complement
additive inverses is for `x == INT_MIN`, which is avoided due to `x < 0`
being true for that case.

> E. x > 0 || -x >= 0

False when `x == INT_MIN`, since `-INT_MIN == INT_MIN`.

> F. x+y == uy+ux

Since we are comparing signed with unsigned types, the comparison coerces
the signed expression result to the unsigned type, in this case `unsigned int`.
Doing `(unsigned)(x+y)` is equivalent to doing `((unsigned)x + (unsigned)y)`,
so this expression is always true.

> G. x*~y + uy*ux == -x

```
x*~y + uy*ux = (unsigned)(x*~y) + uy*ux
```
Distributing the unsigned casting, and considering that bitwise negation done
before or after casting to unsigned is equivalent:

```
x*~y + uy*ux = ux*~uy + uy*ux
ux * (~uy + uy) == (unsigned)(-x)
ux * (2^32) == (unsigned)(-x)
```
Given that `ux*2^32 == ux<<32 == 0`, I would say that this statement is only true
if `x == 0`.
