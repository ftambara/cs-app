> For this exercise, we will examine the code generated by GCC for functions
> that have structures as arguments and return values. From this, we will see
> how these language features are typically implemented.
>
> The following C code has a function `process` with structures as arguments and
> return values, and a function `eval` that calls `process`:
> 
> ```C
> 1  typedef struct {
> 2      long a[2];
> 3      long *p;
> 4  } strA;
> 5
> 6  typedef struct {
> 7      long u[2];
> 8      long q;
> 9  } strB;
> 10
> 11 strB process(strA s) {
> 12     strB r;
> 13     r.u[0] = s.a[1];
> 14     r.u[1] = s.a[0];
> 15     r.q = *s.p;
> 16     return r;
> 17 }
> 18
> 19 long eval(long x, long y, long z) {
> 20     strA s;
> 21     s.a[0] = x;
> 22     s.a[1] = y;
> 23     s.p = &z;
> 24     strB r = process(s);
> 25     return r.u[0] + r.u[1] + r.q;
> 26 }
> ```
> 
> GCC generates the following code for these two functions:
> 
> ```Assembly
>    strB process(strA s)
> 1  process:
> 2      movq %rdi, %rax
> 3      movq 24(%rsp), %rdx
> 4      movq (%rdx), %rdx
> 5      movq 16(%rsp), %rcx
> 6      movq %rcx, (%rdi)
> 7      movq 8(%rsp), %rcx
> 8      movq %rcx, 8(%rdi)
> 9      movq %rdx, 16(%rdi)
> 10     ret
> ```
> 
> ```Assembly
>    long eval(long x, long y, long z)
>    x in %rdi, y in %rsi, z in %rdx
> 1  eval:
> 2      subq $104, %rsp
> 3      movq %rdx, 24(%rsp)
> 4      leaq 24(%rsp), %rax
> 5      movq %rdi, (%rsp)
> 6      movq %rsi, 8(%rsp)
> 7      movq %rax, 16(%rsp)
> 8      leaq 64(%rsp), %rdi
> 9      call process
> 10     movq 72(%rsp), %rax
> 11     addq 64(%rsp), %rax
> 12     addq 80(%rsp), %rax
> 13     addq $104, %rsp
> 14     ret
> ```

> A. We can see on line 2 of function `eval` that it allocates 104 bytes on the
> stack. Diagram the stack frame for `eval`, showing the values that it stores
> on the stack prior to calling `process`.

```
|   old eip   | 104
+-------------+
|      ...    |
|    unused   |  64 <- rdi
+-------------+
|      ...    |
|    unused   |  32
+-------------+
|      z      |  24
+-------------+
|   s.p = &z  |  16
+-------------+
|  s.a[1] = y |   8
+-------------+
|  s.a[0] = x |   0
+-------------+
```

> B. What value does `eval` pass in its call to `process`?

It passes the value at `rdi`, `64(%rsp)`, which is the address of the reserved
space for the return value of `process`. According to the Linux ABI, if the size
of a return object is larger than 16 bytes, it is of type `MEMORY`, and so the
caller is responsible for allocating memory for the return value and passing the
address of that memory in `rdi`.

> C. How does the code for `process` access the elements of structure argument
> `s`?

The passed structure `s` is also of type `MEMORY`, and so it is passed in the
stack. The `process` code accesses `s` from the stack at offsets 8, 16, and 24.

> D. How does the code for `process` set the fields of result structure `r`?

It uses the appropriate offsets with respect to the given address in `rdi`. This
can be seen in lines 6, 8, and 9.

> E. Complete your diagram of the stack frame for `eval`, showing how `eval`
> accesses the elements of structure `r` following the return from `process`.

```
|   old eip   | 104
+-------------+
|      ...    |
|       z     |  80
|       x     |  72
|       y     |  64 <- rdi
+-------------+
|      ...    |
|    unused   |  32
+-------------+
|      z      |  24
+-------------+
|   s.p = &z  |  16
+-------------+
|  s.a[1] = y |   8
+-------------+
|  s.a[0] = x |   0
+-------------+
```

> F. What general principles can you discern about how structure values are
> passed as function arguments and how they are returned as function results?

If the structures to be passed as arguments do not met certain strict criteria
(like being small) they are passed in the stack. The register rdi is used to
pass this address to the callee, and not in the traditional way.
